<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>嵌入式任务调度组件</title>
    <link href="/2023/01/17/%E7%BB%84%E4%BB%B6-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/01/17/%E7%BB%84%E4%BB%B6-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="嵌入式任务调度组件"><a href="#嵌入式任务调度组件" class="headerlink" title="嵌入式任务调度组件"></a>嵌入式任务调度组件</h1><h2 id="一、组件概述"><a href="#一、组件概述" class="headerlink" title="一、组件概述"></a>一、组件概述</h2><p>组件适用于小型嵌入式平台，非抢占式线程需求场景下的任务创建、删除、启动、挂起、延时、恢复功能。</p><h2 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h2><h2 id="三、软件设计"><a href="#三、软件设计" class="headerlink" title="三、软件设计"></a>三、软件设计</h2><h2 id="四、落地实践"><a href="#四、落地实践" class="headerlink" title="四、落地实践"></a>四、落地实践</h2>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>嵌入式组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式状态机组件</title>
    <link href="/2022/11/27/%E7%BB%84%E4%BB%B6-%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/11/27/%E7%BB%84%E4%BB%B6-%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="状态机实现"><a href="#状态机实现" class="headerlink" title="状态机实现"></a>状态机实现</h1><p><a name="UCU9h"></a></p><h2 id="一、模块简介"><a href="#一、模块简介" class="headerlink" title="一、模块简介"></a>一、模块简介</h2><p>状态机组件是模块内部需要进行状态管理时可以使用的一个组件模块，其中业务包含状态机的状态管理，状态机的转换活动、内部活动处理、事件处理等等。<br />状态机的概念：</p><blockquote><p>（ State Machine ）状态机是描述事物有限离散状态互相关系的自动化“机器”，是描述事物的抽象数字模型。<br>什么是状态： 事物任何时刻都有一个状态，同一个状态是指在一段时间内事物具有一定的特征共性。</p></blockquote><blockquote><p><img src="/img/%E7%8A%B6%E6%80%81%E6%9C%BA%E4%B8%BE%E4%BE%8B.png" alt="状态机举例"></p></blockquote><blockquote><p>状态机的四个概念：</p><ol><li>状态：一个状态机至少要包含一个以上的状态，比如上图中一扇门包含打开、关闭两个状态。</li><li>内部活动：在进入状态、退出状态、状态保持时状态机需要执行的动作</li><li>转换活动：状态间的切换动作</li><li>事件：其他模块给状态机发送的消息（事件），状态机根据不同的事件进行处理</li></ol></blockquote><p>其他概念：</p><blockquote><ul><li>伪状态：并非实际的状态节点</li><li>历史状态：简单状态的历史状态表示当前状态进入前的上一个状态。复合状态的历史状态表示上从复合状态退出时复合状态的活动状态<ul><li>浅历史状态：重新进入复合状态时需要进入复合状态的历史状态</li><li>深历史状态：进入复合状态的历史状态时历史状态的参数信息需要按照上次退出时更新</li></ul></li><li>活动状态：复合状态的运行态状态</li></ul></blockquote><p><img src="/img/%E7%8A%B6%E6%80%81%E6%9C%BA%E8%AE%BE%E8%AE%A1.png" alt="简单状态机举例"></p><p><img src="/img/%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8.png" alt="简单状态机举例"></p><p><a name="Mvmhk"></a></p><h2 id="二、模块设计"><a href="#二、模块设计" class="headerlink" title="二、模块设计"></a>二、模块设计</h2><p><a name="CLTzy"></a></p><h3 id="2-1需求分析"><a href="#2-1需求分析" class="headerlink" title="2.1需求分析"></a>2.1需求分析</h3><ul><li>非功能性需求<ul><li>正确性</li><li>可扩展性<ul><li>易用性</li><li>可读性</li><li>可维护性</li></ul></li></ul></li><li>功能性需求<ul><li>基本的被大多数场景下应用</li><li>包含基本状态机的业务：创建、状态切换、事件处理、活动处理</li><li>包含更多复杂状态机需求<ul><li>复合状态业务</li><li>简单状态的历史状态业务</li><li>深历史状态、浅历史状态业务<br><a name="OhLXj"></a></li></ul></li></ul></li></ul><h3 id="2-2设计原理"><a href="#2-2设计原理" class="headerlink" title="2.2设计原理"></a>2.2设计原理</h3><ol><li>状态节点在状态机上的挂载采用指针数组的方式。因为状态节点在使用的过程中不会被释放所以采用指针数组指向节点地址的方式</li><li>复合状态具有事件处理函数、状态节点指针列表、活动状态。这些在状态机类型上同样存在，同样在简单状态上具有相似的属性特征。所以简单状态、复合状态、状态机类型采用相同的类型。在具体使用的过程中进行区分。<ul><li>“状态机类型也可以看作复合状态类型、复合状态类型也可以看作简单状态类型”</li><li>“复合状态类型继承简单状态类型，状态机类型继承复合状态类型”</li></ul></li><li>深历史状态与浅历史状态的区别在于深历史状态在退出时记录了状态的“子状态&#x2F;参数信息”，所以每个状态在设计的过程中需要考虑状态的特点再决定什么类型。深历史状态和浅历史状态的<strong>进入活动</strong>需要通过传参进行区分。</li><li>简单状态的历史状态、复合状态的活动状态和历史状态、状态机的活动状态采用同一个成员表示</li><li>状态转换关系需要在软件设计阶段提前设定好，状态机的所有状态转换都应该是可预知的</li><li>状态机的起点是一个顶层状态，顶层状态是一个复合状态</li><li>复合状态属于伪状态，复合状态的内部活动实际是内部活动状态的内部活动</li><li>复合状态具有单独的事件处理方法，这个也是简单状态划分为复合状态的依据：具有相同事件的事件处理方法的一类简单状态可划分为一个复合状态的子状态<br><a name="ADVzY"></a></li></ol><h2 id="三、最佳实践"><a href="#三、最佳实践" class="headerlink" title="三、最佳实践"></a>三、最佳实践</h2><p><img src="/img/%E6%B4%97%E8%A1%A3%E6%9C%BA%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="洗衣机状态转换关系图"></p><p><img src="/img/%E6%B4%97%E8%A1%A3%E6%9C%BA%E7%8A%B6%E6%80%81%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="洗衣机状态层次关系图"></p><p><a href="https://github.com/daxia-hu/cuteFsm">cuteFsm-github</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FsmSimpleNode_t</span> <span class="hljs-title">FsmSimpleNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FsmObj_t</span> <span class="hljs-title">FsmObj</span>;</span><br><span class="hljs-comment">// 转换类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br>    TRANS_RESET,<br>    TRANS_RECORD,<br>&#125; TRANS_TYPE;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*entryHandle)</span><span class="hljs-params">(TRANS_TYPE transType)</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*exitHandle)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*workHandle)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*eventHandle)</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> event, <span class="hljs-type">uint32_t</span> param)</span>;<br><br><span class="hljs-comment">// 状态机类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FsmObj_t</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint8_t</span> active;      <span class="hljs-comment">// 复合状态时为活动状态，简单状态时为历史状态</span><br>    FsmObj* super;       <span class="hljs-comment">// 所属的父节点</span><br>    entryHandle entry;   <span class="hljs-comment">// 进入活动</span><br>    exitHandle <span class="hljs-built_in">exit</span>;     <span class="hljs-comment">// 退出活动</span><br>    workHandle work;     <span class="hljs-comment">// 轮询活动</span><br>    eventHandle event;   <span class="hljs-comment">// 事件回调</span><br>    FsmObj **node;       <span class="hljs-comment">// 子状态列表</span><br>&#125; FsmObj;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 状态机初始化</span><br><span class="hljs-comment"> * @param workObj 最终活动状态</span><br><span class="hljs-comment"> * @param targetObj 初始状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FSM_init</span><span class="hljs-params">(FsmObj *workObj,FsmObj *initObj)</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 状态机状态切换 参数重置</span><br><span class="hljs-comment"> * @param workObj 当前状态</span><br><span class="hljs-comment"> * @param workObj 目标状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FSM_transState</span><span class="hljs-params">(FsmObj *workObj,FsmObj *targetObj)</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 状态机状态返回 参数不重置</span><br><span class="hljs-comment"> * @param workObj 当前状态</span><br><span class="hljs-comment"> * @param workObj 目标状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FSM_backState</span><span class="hljs-params">(FsmObj *workObj,FsmObj *targetObj)</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 状态机事件执行函数</span><br><span class="hljs-comment"> * @param workObj 当前状态</span><br><span class="hljs-comment"> * @param event 事件ID</span><br><span class="hljs-comment"> * @param param 参数ID</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FSM_eventHandle</span><span class="hljs-params">(FsmObj *workObj,<span class="hljs-type">uint32_t</span> event,<span class="hljs-type">uint32_t</span> param)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 状态机初始化</span><br><span class="hljs-comment"> * @param workObj 最终活动状态</span><br><span class="hljs-comment"> * @param targetObj 初始状态</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FSM_init</span><span class="hljs-params">(FsmObj *workObj,FsmObj *initObj)</span><br>&#123;<br>    ASSERT(<span class="hljs-literal">NULL</span> != workObj);<br>    ASSERT(<span class="hljs-literal">NULL</span> != initObj);<br>    workObj = initObj;<br>    <span class="hljs-keyword">if</span>(workObj-&gt;entry)<br>    &#123;<br>        workObj-&gt;entry(TRANS_RESET);<br>    &#125;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">func_FsmTrans</span><span class="hljs-params">(FsmObj *workObj,FsmObj *targetObj,TRANS_TYPE type)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>((<span class="hljs-literal">NULL</span> != workObj) &amp;&amp; (<span class="hljs-literal">NULL</span> != targetObj))<br>    &#123;<br>        <span class="hljs-keyword">if</span>(workObj-&gt;<span class="hljs-built_in">exit</span>)<br>        &#123;<br>            workObj-&gt;<span class="hljs-built_in">exit</span>();<br>        &#125;<br>        <span class="hljs-built_in">memcpy</span>(workObj,targetObj,<span class="hljs-keyword">sizeof</span>(targetObj));<br>        <span class="hljs-keyword">if</span>(workObj-&gt;entry)<br>        &#123;<br>            workObj-&gt;entry(type);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 状态机状态切换 参数重置</span><br><span class="hljs-comment"> * @param workObj 当前状态</span><br><span class="hljs-comment"> * @param workObj 目标状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FSM_transState</span><span class="hljs-params">(FsmObj *workObj,FsmObj *targetObj)</span><br>&#123;<br>    func_FsmTrans(workObj,targetObj,TRANS_RESET);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 状态机状态返回 参数不重置</span><br><span class="hljs-comment"> * @param workObj 当前状态</span><br><span class="hljs-comment"> * @param workObj 目标状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FSM_backState</span><span class="hljs-params">(FsmObj *workObj,FsmObj *targetObj)</span><br>&#123;<br>    ASSERT(<span class="hljs-literal">NULL</span> != workObj);<br>    ASSERT(<span class="hljs-literal">NULL</span> != targetObj);<br>    func_FsmTrans(workObj,targetObj,TRANS_RECORD);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 状态机事件执行函数</span><br><span class="hljs-comment"> * @param workObj 当前状态</span><br><span class="hljs-comment"> * @param event 事件ID</span><br><span class="hljs-comment"> * @param param 参数ID</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FSM_eventHandle</span><span class="hljs-params">(FsmObj *workObj,<span class="hljs-type">uint32_t</span> event,<span class="hljs-type">uint32_t</span> param)</span><br>&#123;<br>    ASSERT(<span class="hljs-literal">NULL</span> != workObj);<br>    <span class="hljs-keyword">if</span>(workObj-&gt;event)<br>    &#123;<br>        workObj-&gt;event(event,param);<br>    &#125;<br>    FsmObj *workSuper = workObj-&gt;super;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">NULL</span> != workSuper)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(workSuper-&gt;event)<br>        &#123;<br>            workSuper-&gt;event(event,param);<br>        &#125;<br>        workSuper = workSuper-&gt;super;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式动态内存管理组件</title>
    <link href="/2022/11/17/%E7%BB%84%E4%BB%B6-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/11/17/%E7%BB%84%E4%BB%B6-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="嵌入式动态内存管理组件"><a href="#嵌入式动态内存管理组件" class="headerlink" title="嵌入式动态内存管理组件"></a>嵌入式动态内存管理组件</h1><h2 id="一、组件描述"><a href="#一、组件描述" class="headerlink" title="一、组件描述"></a>一、组件描述</h2><p>动态内存管理指的是在程序需要内存时申请，在使用完成后释放，保证以比较少的内存实现更多的软件需求。与之相对的是静态内存，典型的静态内存就是全局变量：在程序启动时到整个生命空间内都占用空间。动态内存的特点就是实现内存的“按需使用”，在嵌入式开发环境中，节省ram实现更多更灵活的内存使用需求。</p><p>c库中的malloc、free接口就是动态内存申请、释放的实现。在《深入理解计算机系统》书中针对c库中malloc的实现算法有一章的篇幅进行说明。</p><h2 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h2><p>动态内存的管理对外应该只需要提供两个接口：申请、释放。申请需要指定需要申请的内存大小，申请时存在剩余内存不足导致申请失败的场景所以需要在返回值中指定失败时的返回地址为NULL；内存的释放只需要将内存地址作为参数进行释放。遵守依赖倒置原则，接口的实现依赖于抽象的需求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 内存申请</span><br><span class="hljs-comment"> * @param size 需要申请的内存大小</span><br><span class="hljs-comment"> * @return 申请的内存地址，NULL表示为申请失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 内存的释放</span><br><span class="hljs-comment"> * @param p 待释放的内存首地址</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *p)</span>;<br></code></pre></td></tr></table></figure><h2 id="三、设计实现"><a href="#三、设计实现" class="headerlink" title="三、设计实现"></a>三、设计实现</h2><h3 id="3-1-设计目标"><a href="#3-1-设计目标" class="headerlink" title="3.1 设计目标"></a>3.1 设计目标</h3><ul><li>非功能性目标</li></ul><ol><li>易用性</li><li>健壮性</li><li>正确性</li></ol><ul><li>功能性目标</li></ul><ol><li>实现内存使用需求</li><li>实现内存的高效管理需求</li></ol><h3 id="3-2-设计原理"><a href="#3-2-设计原理" class="headerlink" title="3.2 设计原理"></a>3.2 设计原理</h3><ul><li>未使用的内存块节点采用空间从小到大排列的双向链表进行管理。这样在申请时能快速按照需求找到合适大小的内存块<br><img src="/img/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%93%BE%E8%A1%A8.png" alt="内存管理链表"></li><li>内存释放时需要按照内存地址与最近的块进行合并，合并后重新插入到链表中的合适位置去</li><li>内存模块初始化时整个空间都是空闲链表的一个节点</li><li>空闲内存块节点包含链表头信息，在释放之前不可以被修改。</li><li>链表头的内容包含<ul><li>魔鬼数字：表示内存头信息，也可以用于检测内存是否被踩踏</li><li>可使用内存起始地址信息</li><li>可使用内存大小信息</li><li>指向下一个节点的指针</li><li>指向前一个节点的指针<br><img src="/img/%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98%E5%9D%97%E8%8A%82%E7%82%B9%E7%BB%84%E6%88%90.png" alt="空闲内存块节点组成"></li></ul></li></ul><h3 id="3-3-关键流程"><a href="#3-3-关键流程" class="headerlink" title="3.3 关键流程"></a>3.3 关键流程</h3><ul><li>内存申请实现流程</li></ul><p><img src="/img/%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B.png" alt="内存申请流程"></p><ul><li>内存释放实现流程</li></ul><p><img src="/img/%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E6%B5%81%E7%A8%8B.png" alt="内存释放流程"></p><h2 id="四、落地实践"><a href="#四、落地实践" class="headerlink" title="四、落地实践"></a>四、落地实践</h2>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式IPC组件</title>
    <link href="/2022/11/17/%E7%BB%84%E4%BB%B6-IPC%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/11/17/%E7%BB%84%E4%BB%B6-IPC%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="IPC组件"><a href="#IPC组件" class="headerlink" title="IPC组件"></a>IPC组件</h1><h2 id="一、模块简介"><a href="#一、模块简介" class="headerlink" title="一、模块简介"></a>一、模块简介</h2><p>IPC（Interprocess communication）模块是指模块间通信模块，主要实现的功能是消息的订阅、消息的发送接收处理业务。模块的功能比较简单，实现也相对简单。</p><h2 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h2><ul><li>模块间的消息传递一对多消息和一对一消息，所有的消息都是先经过IPC模块再进行分发，按照模块的消息订阅情况判断消息是否需要分发给每个模块。</li><li>消息从发送模块到接收模块要求比较高的执行效率。</li></ul><h2 id="三、架构设计"><a href="#三、架构设计" class="headerlink" title="三、架构设计"></a>三、架构设计</h2><ul><li>IPC模块的设计复合设计模式中的代理设计模式，除了IPC以外的业务模块通过IPC模块实现间接通信，解除模块之间的耦合。</li><li>IPC的通信分为同步处理和异步处理，选择拿种处理方式需要结合产品的特点、软件整体设计综合考虑</li><li>IPC的异步处理可能会出现消息没来及消费的问题，如果阻塞则会影响生产者消息传递，并且有消息丢失的可能性。阻塞时间需要短或者不阻塞，为了保证消息不丢失需要在消息队列溢出时把溢出的消息及时消费。</li><li>IPC模块与其他模块的交互就是消息的接收和消息的转发，消息的接收可以是一个统一的接口给其他模块调用，消息的分发需要保存一张消息接收的表，表头包含模块的订阅判断函数指针。</li><li>应用场景<br><img src="/img/IPC%E4%B8%80%E5%AF%B9%E4%B8%80.png" alt="一对一消息"><br><img src="/img/IPC%E4%B8%80%E5%AF%B9%E5%A4%9A.png" alt="一对多消息"></li></ul><h2 id="落地实践"><a href="#落地实践" class="headerlink" title="落地实践"></a>落地实践</h2><p><a href="https://github.com/daxia-hu/cuteIpc">实践仓库-github</a></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式按键检测组件</title>
    <link href="/2022/11/17/%E7%BB%84%E4%BB%B6-%E6%8C%89%E9%94%AE%E6%A3%80%E6%B5%8B%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/11/17/%E7%BB%84%E4%BB%B6-%E6%8C%89%E9%94%AE%E6%A3%80%E6%B5%8B%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="按键检测模块"><a href="#按键检测模块" class="headerlink" title="按键检测模块"></a>按键检测模块</h1><h2 id="模块简介"><a href="#模块简介" class="headerlink" title="模块简介"></a>模块简介</h2><p>按键检测模块用于嵌入式系统上实现按键的扫描，实现按键的触发检测，并对短按、长按等状态进行识别检测。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>按键检测需要可以识别多个按键的多种事件触发，并且需要对事件做出响应处理。</p><ul><li>功能性需求<ol><li>可以实现多个按键检测</li><li>实现按键扫描事件检测和事件回调触发</li></ol></li><li>非功能性需求<ol><li>方便移植</li><li>方便添加按键</li><li>代码实现简洁易读</li></ol></li></ul><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><ul><li>可读性</li><li>可移植性</li><li>可拓展性</li></ul><h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h3><ul><li>单个按键对象的方法包含按键的触发识别函数和按键的事件处理函数</li><li>单个按键需要状态管理，这些状态的触发条件包含按键触发和时间触发</li><li>按键管理组件包含多个按键，这些按键的业务相同，所以需要统一管理</li><li>多个按键可以采用链表、数组等方式进行管理</li><li>基本状态设计<br><img src="/img/%E6%8C%89%E9%94%AE%E6%A8%A1%E5%9D%97%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.png" alt="按键模块状态切换"><br>采用两种方案设计</li></ul><ol><li>链表方案<ul><li>链表的实现参照<a href="https://hudaxia.top/2022/10/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/">链表知识</a></li><li>按键类包含的成员如下 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 按键类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br>    KEY_IDLE,  <span class="hljs-comment">//空闲</span><br>    KEY_PRESS,  <span class="hljs-comment">//按下</span><br>    KEY_RELEASE,  <span class="hljs-comment">//释放</span><br>    KEY_SHORT_CLICK,  <span class="hljs-comment">//短按</span><br>    KEY_LONG_CLICK,  <span class="hljs-comment">//长按</span><br>    KEY_DOUBLE_CLICK, <span class="hljs-comment">//双击</span><br>    KEY_LONG_HOLD,  <span class="hljs-comment">//长按保持</span><br>&#125; KEY_STATE;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_LONGPRESS_TICK 200</span><br><span class="hljs-comment">/* 按键检测函数指针 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">uint8_t</span> <span class="hljs-params">(*det_func)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">/* 按键状态变化函数指针 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*handle_func)</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> key_id, <span class="hljs-type">uint8_t</span> key_state)</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Key_t</span></span><br><span class="hljs-class">&#123;</span><br>    Node node;   <span class="hljs-comment">//节点</span><br>    <span class="hljs-type">uint8_t</span> key_id;   <span class="hljs-comment">//按键ID</span><br>    <span class="hljs-type">uint8_t</span> state;   <span class="hljs-comment">//按键状态</span><br>    det_func detFunc;      <span class="hljs-comment">//按键检测函数</span><br>    handle_func handleFunc;    <span class="hljs-comment">//状态变化回调函数</span><br>    <span class="hljs-type">uint16_t</span> tick;   <span class="hljs-comment">//按键tick</span><br>&#125; Key;<br></code></pre></td></tr></table></figure></li><li>采用链表在初始化阶段创建链表并将按键节点插入到链表中</li><li>采用链表遍历的方式查询按键状态</li></ul></li><li>数组指针方案设计<ul><li>包含按键检测类和按键类两个类</li><li>实现思路与链表大致相同但是可读性更强一点 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 按键状态 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br>    BUTTON_STATE_IDLE,<br>    BUTTON_STATE_RELEASE,<br>    BUTTON_STATE_PRESS,<br>    BUTTON_STATE_SHORT_CLICK,<br>    BUTTON_STATE_LONG_CLICK,<br>&#125;BUTTON_STATE_TYPE;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUTTON_LONGCLICK_TIMEOUT 1000</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* @brief 获取按键状态函数指针 </span><br><span class="hljs-comment">* @return TRUE 按键被触发 FALSE 按键被释放</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">uint8_t</span> <span class="hljs-params">(*func_GetButtonState)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">/* 按键类 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Button_T</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint8_t</span> ButtonId;                     <span class="hljs-comment">//按键的ID信息</span><br>    <span class="hljs-type">uint8_t</span> state;                        <span class="hljs-comment">//按键当前状态</span><br>    <span class="hljs-type">uint32_t</span> tick;                        <span class="hljs-comment">//按键时间参数</span><br>    func_GetButtonState func_ButtonState; <span class="hljs-comment">//获取按键状态的函数成员</span><br>&#125; Button;<br><span class="hljs-comment">/* 按键模块的事件回调函数指针 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*func_ButStateChangeHandle)</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> but_id, <span class="hljs-type">uint8_t</span> state)</span>;<br><span class="hljs-comment">/* 按键模块类 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Mod_Button_t</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint8_t</span> ButtonNum;                          <span class="hljs-comment">//按键个数</span><br>    Button **ButtonList;                        <span class="hljs-comment">//按键列表的地址</span><br>    func_ButStateChangeHandle func_EventHandle; <span class="hljs-comment">//按键模块的事件回调函数</span><br>&#125; Mod_Button;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="落地实践"><a href="#落地实践" class="headerlink" title="落地实践"></a>落地实践</h2><p><a href="https://github.com/daxia-hu/cuteButton">实践仓库-github</a></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式消息队列组件</title>
    <link href="/2022/11/17/%E7%BB%84%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/11/17/%E7%BB%84%E4%BB%B6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="消息队列组件"><a href="#消息队列组件" class="headerlink" title="消息队列组件"></a>消息队列组件</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>消息队列组件目标是实现消息队列结构，结合IPC组件实现模块间的异步通信。消息队列实现</p><h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><ul><li>功能目标<ul><li>正确性</li></ul></li><li>性能目标<ul><li>易用性</li><li>可拓展性</li><li>稳定性</li></ul></li></ul><h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h3><p>消息队列采用fifo的队列数据结构，fifo指的是“first in，first out”，先进先出，消费的顺序与生产的顺序一致。<br><img src="/img/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png" alt="消息队列"><br>设计中的关键点：</p><ol><li>消息体可以是任意结构，所以消息的存取都采用指针的方式只传递地址</li><li>写失败的唯一原因是，消息的实际大小个数已经等于最大个数，此时消息队列内已无多余的空间用于存储新的消息体</li><li>读失败的唯一原因是，实际的消息数量为0</li><li>消息内部创建的时候不提供消息的存储空间，需要在创建时将静态内存或者动态内存好的内存当作参数传递给消息队列类型对象</li></ol><p>对外接口</p><ul><li>创建消息队列对象<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 创建消息队列</span><br><span class="hljs-comment"> * @param queue 消息队列对象</span><br><span class="hljs-comment"> * @param msgNum 消息数量</span><br><span class="hljs-comment"> * @param data 数据指针</span><br><span class="hljs-comment"> */</span><br>void <span class="hljs-constructor">Queue_creat(Queue <span class="hljs-operator">*</span><span class="hljs-params">queue</span>, <span class="hljs-params">uint8_t</span> <span class="hljs-params">msgNum</span>, <span class="hljs-params">uint8_t</span> <span class="hljs-params">msgSize</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>)</span>;<br></code></pre></td></tr></table></figure></li><li>消息推送<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@brief</span> 推送消息到消息队列中</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> queue 消息队列对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg 待推送的消息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 推送成功或者失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">uint8_t <span class="hljs-title">Queue_push</span><span class="hljs-params">(Queue *queue, <span class="hljs-keyword">void</span> *msg)</span></span>;<br></code></pre></td></tr></table></figure></li><li>消息取出<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@brief</span> 从消息队列中取出消息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> queue 消息队列对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg 待取出的消息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 取出成功或者失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">uint8_t <span class="hljs-title">Queue_pull</span><span class="hljs-params">(Queue *queue, <span class="hljs-keyword">void</span> *msg)</span></span>;<br></code></pre></td></tr></table></figure><img src="/img/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%B6%88%E6%81%AF%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B.png" alt="消息队列收发流程"></li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p><a href="https://github.com/daxia-hu/cuteQueue">github仓库</a></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式UI管理组件</title>
    <link href="/2022/11/12/%E7%BB%84%E4%BB%B6-UI%E8%B0%83%E5%BA%A6%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/11/12/%E7%BB%84%E4%BB%B6-UI%E8%B0%83%E5%BA%A6%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="通用型UI界面切换管理实现"><a href="#通用型UI界面切换管理实现" class="headerlink" title="通用型UI界面切换管理实现"></a>通用型UI界面切换管理实现</h1><h2 id="一、模块简介"><a href="#一、模块简介" class="headerlink" title="一、模块简介"></a>一、模块简介</h2><ul><li>UI调度组件是在小型嵌入式界面切换产品上实现的界面切换控制管理通用型模块。</li></ul><h2 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h2><ul><li>目标实现的是一个通用型嵌入式设备上的UI切换管理组件，应用的场景包括但不限于如下LCD嵌入式产品的UI界面<br><img src="/img/UIdemo.png" alt="简单的界面展示"></li><li>功能性需求：<ol><li>能适用于大多数场景下的UI界面切换</li><li>使界面方便管理，界面间关系可读性高</li><li>包含固定界面与弹窗类界面的切换业务实现</li><li>需要包含弹窗类界面进入退出时的历史界面保持</li><li>包含两种界面切换方式<ul><li>记录当前界面状态的切换</li><li>销毁当前界面状态的切换</li></ul></li><li>普通界面直接切换也可以保存历史信息，如从列表界面进入指定界面再退出时需要记录列表界面的历史选择项</li><li>弹窗类界面与普通界面的区别是弹窗类界面存在历史界面且从弹窗界面进入弹窗界面时需要做到历史界面的传递<br><img src="/img/%E7%95%8C%E9%9D%A2%E5%88%87%E6%8D%A2%E5%9C%BA%E6%99%AF.png" alt="界面切换场景"></li></ol></li><li>非功能性需求：<ol><li>能适配大多数UI显示及led显示业务</li><li>能够快速合入到项目中使用不需要太多的学习成本</li><li>如果不能满足特定场景下的使用要求可读性高方便使用者自有改动</li></ol></li></ul><h2 id="三、架构设计"><a href="#三、架构设计" class="headerlink" title="三、架构设计"></a>三、架构设计</h2><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><ul><li>可移植性</li><li>易用性</li><li>可读性</li></ul><h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h3><ul><li>UI界面在项目交互方案给出以后是确定的，UI对象中包含UI的绘制、UI界面对事件的判断、动态UI的业务、UI界面退出时的UI空间对象销毁、界面类型（普通界面与弹窗类界面）、历史界面。</li><li>UI调度器类需要包含界面列表的指针（指针数组的指针）、当前界面的ID、总界面个数。</li><li>历史界面的进入和退出与普通界面的切换需要根据参数进行区分<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br>    PAGE_TYPE_NORMAL,  <span class="hljs-comment">//普通界面</span><br>    PAGE_TYPE_MSEEAGE, <span class="hljs-comment">//弹窗类界面</span><br>&#125; UIPAGE_TYPE;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br>    INIT_PARAM_RESET,   <span class="hljs-comment">//返回重新绘制界面</span><br>    INIT_PARAM_RECORD,  <span class="hljs-comment">//按照上次的参数返回</span><br>&#125;UIPAGE_INIT_PARAM;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Gui_t</span> <span class="hljs-title">Gui</span>;</span><br><span class="hljs-comment">/* 界面初始化处理函数 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*uiInitHandle)</span><span class="hljs-params">(Gui *gui,<span class="hljs-type">uint8_t</span> type)</span>;<br><span class="hljs-comment">/* 界面退出处理函数 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*uiExitHandle)</span><span class="hljs-params">(Gui *gui)</span>;<br><span class="hljs-comment">/* 界面业务处理函数 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*uiWorkHandle)</span><span class="hljs-params">(Gui *gui)</span>;<br><span class="hljs-comment">/* 界面事件处理函数 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*uiEventHandle)</span><span class="hljs-params">(Gui *gui, <span class="hljs-type">uint32_t</span> event, <span class="hljs-type">uint32_t</span> param)</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageNode_t</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint16_t</span> pageType;   <span class="hljs-comment">//界面类型</span><br>    <span class="hljs-type">uint16_t</span> pageBack;   <span class="hljs-comment">//界面的历史界面</span><br>    uiInitHandle init;   <span class="hljs-comment">//界面构造函数、界面的绘制、数据的填充</span><br>    uiExitHandle <span class="hljs-built_in">exit</span>;   <span class="hljs-comment">//界面退出的析构函数</span><br>    uiWorkHandle work;   <span class="hljs-comment">//界面需要循环执行的业务函数如动画</span><br>    uiEventHandle event; <span class="hljs-comment">//界面的时间回调函数</span><br>&#125; PageNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Gui_t</span></span><br><span class="hljs-class">&#123;</span><br>    PageNode **nodeList; <span class="hljs-comment">//调度器挂载的界面列表</span><br>    <span class="hljs-type">uint16_t</span> num;        <span class="hljs-comment">//总挂载的界面个数</span><br>    <span class="hljs-type">uint16_t</span> page;       <span class="hljs-comment">//当前显示的界面</span><br>    <span class="hljs-type">void</span> *uiPtr;         <span class="hljs-comment">//界面包含的参数指针 可以在界面之间进行参数传递</span><br>&#125; Gui;<br></code></pre></td></tr></table></figure></li></ul><h2 id="四、落地实践"><a href="#四、落地实践" class="headerlink" title="四、落地实践"></a>四、落地实践</h2><p><a href="https://github.com/daxia-hu/cuteGui">UI调度器实现-github</a></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>费曼学习法</title>
    <link href="/2022/10/15/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    <url>/2022/10/15/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>假设你是一个程序员初学者，你刚学习完语法中的“循环”结构，现在先把你从未接触过计算机语言的女朋友叫到你面前，试着用通俗的词汇给她讲明白循环的实现的原理，循环的应用场景举例。让她明白循环是干什么的，循环的实现原理是什么，再去给她讲循环的具体实现。当给她讲明白后她能对循环进行应用说明你的循环已经学懂了。这个就是费曼学习法的主要思想：以输出倒逼输入。</p></blockquote><h2 id="什么是费曼学习法"><a href="#什么是费曼学习法" class="headerlink" title="什么是费曼学习法"></a>什么是费曼学习法</h2><p>费曼学习法，也称费曼技巧，英文原文是 Feynman Technique。费曼学习法和费曼技巧指代同一个概念，在文中根据上下文而选定用哪个名词。费曼是个人名，没错，就是那个讲课很生动的物理学家，他是诺贝尔奖得主。</p><p>其实这一个朴素的方法，我们可能早就知道这个方法，关于学习的方法论，这是个很实用的方法。核心就是：Learning by teaching。另外，白居易的诗有时要念给老妇人，大概也是同一个道理。</p><ul><li>“有结果检验的导向 + 功利 + 逻辑”</li><li>“现学现卖，消化最快”：刚学的知识教别人，消化最快</li><li>“即时反馈”：学习可以达到即时反馈，这是游戏引人入胜的原理之一</li><li>“简洁”：简洁不是真相的表现形式，而是真相本身</li></ul><p>事实证明，我们欺骗自己的方法之一是我们使用了复杂的词汇和行话，这掩盖了我们缺乏理解。</p><p>“The person who says he knows what he thinks but cannot express it usually does not know what he thinks.” — Mortimer Adler</p><p>翻译：那些声称清楚自己所想，但却不能清晰表达的人，其实通常不知道自己所想。</p><h2 id="费曼学习法的步骤"><a href="#费曼学习法的步骤" class="headerlink" title="费曼学习法的步骤"></a>费曼学习法的步骤</h2><h3 id="Step-1：选定要学习的概念"><a href="#Step-1：选定要学习的概念" class="headerlink" title="Step 1：选定要学习的概念"></a>Step 1：选定要学习的概念</h3><h3 id="Step-2：假装正在将其教给6年级的学生"><a href="#Step-2：假装正在将其教给6年级的学生" class="headerlink" title="Step 2：假装正在将其教给6年级的学生"></a>Step 2：假装正在将其教给6年级的学生</h3><p>六年级的学生只是一个泛指，主要是他的词汇量和认知足以理解基本概念以及基本概念之间的关系。</p><p>在第2步如果在解释过程中，”卡壳”，即无法用简单的语言叙述时或者发现自己其实不是透彻了解时，那么去学习原材料或者学习其他材料（这个称之为 review，复习即再次学习），直到没有任何”卡壳”点。</p><h3 id="Step-3：条理化、简化"><a href="#Step-3：条理化、简化" class="headerlink" title="Step 3：条理化、简化"></a>Step 3：条理化、简化</h3><p>整理前面得到的自己话的表达，使之更有条理。组织成可以说出来的口头材料，大声朗读。如果叙述起来不简单或听起来令人困惑，则说明在该领域的理解仍需要一些工作，继续研究直到听起来易懂无困惑点。</p><p>或者说，讲述时尽量不用术语。</p><h3 id="Step-4：找真人来”教”（可选）"><a href="#Step-4：找真人来”教”（可选）" class="headerlink" title="Step 4：找真人来”教”（可选）"></a>Step 4：找真人来”教”（可选）</h3><p>第4步是可选。如果您真的想检验自己的是否真正理解，那去找个真人来”教”（最好是对这门学科了解甚少的人，或者找个真正的十二岁的孩子！）。对您的知识的最终考验是您将知识传达给他人的能力。</p><p>当您与某人交谈时，他们开始使用您不理解的单词或关系时，请他们像您12岁时向您解释。您不仅可以加强自己的学习，而且还可以加强他们的学习。重要的是，以这种方式解决问题可以让您了解其他人不知道他们在说什么。</p><p><a href="https://www.liaolijun.com/feynman-technique/#:~:text=%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95%EF%BC%8C%E4%B9%9F%E7%A7%B0%E8%B4%B9%E6%9B%BC%E6%8A%80%E5%B7%A7%EF%BC%8C%E8%8B%B1%E6%96%87%E5%8E%9F%E6%96%87%E6%98%AF,Feynman%20Technique%E3%80%82">《费曼学习法》</a></p>]]></content>
    
    
    <categories>
      
      <category>学习方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件设计原则</title>
    <link href="/2022/10/11/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/2022/10/11/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>软件设计原则是指软件在架构设计或者在详细设计过程中所需要遵循的原则，现有的软件设计模式都是在不同场景下对软件设计原则的应用，良好的软件项目实践都会在设计及编码阶段思考或者遵循常见的设计原则来实现最终的设计目标。</p><p>设计原则的最终目的是使软件产品能实现指定的设计目标，这些目标包含：</p><ul><li>正确性</li><li>健壮性</li><li>灵活性</li><li>可复用性</li><li>高效性</li><li>可插入性</li></ul><p>七大软件设计原则是在软件发展至今被行业前沿的优秀从业者所总结，被行业内大多数所任何的优秀原则。每一项原则的侧重点不同角度不同，在实际项目中需要结合实际的项目特点实际思考在不同场景下选择最合适的原则做出优秀的设计产品。</p><h2 id="开闭原则（OCP）"><a href="#开闭原则（OCP）" class="headerlink" title="开闭原则（OCP）"></a>开闭原则（OCP）</h2><ul><li>原则描述<br>开闭原则（Open Closed Principle，OCP）是勃兰特·梅耶在他 1988 年的著作《面向对象软件构造》中首次提出的：<blockquote><p>软件实体应当对扩展开放，对修改关闭。<br>Software entities should be open for extension，but closed for modification.<br>具体含义是：<br>当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p></blockquote></li><li>原则实现<br>这一原则的重要性是不言而喻的，谁都希望自己的代码能够在反复迭代的需求中仅通过扩展已有功能就可以满足新的需求，而不是一个简单的新需求就让整个代码必须发生重构。<br>那么，如何实现这一原则呢？“抽象约束、封装变化”是一个很好的方法。<br>简单的来说，就是通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。<br>只要抽象层能够覆盖足够多的场景，那么，即使实现层无法满足新的需求，也只需要扩展实现层即可，而不需要改变底层的抽象设计。</li><li>提高系统稳定性，扩展新功能时，不修改原来的代码，就不会影响系统已有的功能。提高系统扩展性，因为开闭原则的目的就是对扩展开发<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 获取按键状态函数指针 </span><br><span class="hljs-comment"> * @return TRUE 按键被触发 FALSE 按键被释放</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">uint8_t</span> <span class="hljs-params">(*func_GetButtonState)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">/* 按键类 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Button_T</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint8_t</span> ButtonId;                     <span class="hljs-comment">//按键的ID信息</span><br>    <span class="hljs-type">uint8_t</span> state;                        <span class="hljs-comment">//按键当前状态</span><br>    <span class="hljs-type">uint32_t</span> tick;                        <span class="hljs-comment">//按键时间参数</span><br>    <span class="hljs-type">uint32_t</span> hold_tick;                   <span class="hljs-comment">//长按保持时间参数</span><br>    func_GetButtonState func_ButtonState; <span class="hljs-comment">//获取按键状态的函数成员</span><br>&#125; Button;<br><span class="hljs-comment">/* 按键模块的事件回调函数指针 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*func_ButStateChangeHandle)</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> but_id, <span class="hljs-type">uint8_t</span> state)</span>;<br><span class="hljs-comment">/* 按键模块类 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Mod_Button_t</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint8_t</span> ButtonNum;                          <span class="hljs-comment">//按键个数</span><br>    Button **ButtonList;                        <span class="hljs-comment">//按键列表的地址</span><br>    func_ButStateChangeHandle func_EventHandle; <span class="hljs-comment">//按键模块的事件回调函数</span><br>&#125; Mod_Button;<br></code></pre></td></tr></table></figure>在上面的按键检测组件代码中，如果需要新增按键，只需要将新按键的驱动添加到按键链表中，这样就可以直接使用。不要在按键检测业务实现内部再新增按键的什么业务。所以按键检测的业务实现了对扩展打开，对修改关闭。</li></ul><h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><ul><li>原则描述</li></ul><p>单一职责原则是由罗伯特·C.马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中提出的：</p><blockquote><p>一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。<br>There should never be more than one reason for a class to change.</p></blockquote><p>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：</p><ol><li>一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；</li><li>当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。</li></ol><p>不仅是类的设计，单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。</p><ul><li>原则实现<br>当一个类只具有一个职责时，那么当这个职责发生变化，我们可以非常肯定地说没有其他类需要变更，这在可维护性上来说是很强的。<br>例如在创建“程序员”类时，你可能会考虑到程序员需要具有写代码、测试、调试、运行维护等方法，但事实上，写代码的职责与其他职责并不相关，测试、调试的职责也非常独立，运行维护的职责也是同样，因此，如果将“程序员”类拆分为“程序员”类、“测试”类、“运维”类三个类，项目的可维护性便可以大为加强。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  config usart</span><br><span class="hljs-comment">  * @param  none</span><br><span class="hljs-comment">  * @retval none</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">usart_configuration</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <br>    <span class="hljs-comment">/* enable pwc periph clock */</span><br>    crm_periph_clock_enable(CRM_PWC_PERIPH_CLOCK, TRUE);<br><br>    <span class="hljs-comment">/* config ldo voltage */</span><br>    pwc_ldo_output_voltage_set(PWC_LDO_OUTPUT_1V3);<br><br>    <span class="hljs-comment">/* set the flash clock divider */</span><br>    flash_clock_divider_set(FLASH_CLOCK_DIV_3);<br><br>    <span class="hljs-comment">/* reset crm */</span><br>    crm_reset();<br><br>    crm_clock_source_enable(CRM_CLOCK_SOURCE_HEXT, TRUE);<br><br>    <span class="hljs-comment">/* wait till hext is ready */</span><br>    <span class="hljs-keyword">while</span>(crm_hext_stable_wait() == ERROR)<br>    &#123;<br>    &#125;<br><br>    <span class="hljs-comment">/* config pll clock resource</span><br><span class="hljs-comment">    common frequency config list: pll source selected  hick or hext(8mhz)</span><br><span class="hljs-comment">    _________________________________________________________________________________________________</span><br><span class="hljs-comment">    |        |         |         |         |         |         |         |         |        |        |</span><br><span class="hljs-comment">    |pll(mhz)|   288   |   252   |   216   |   192   |   180   |   144   |   108   |   72   |   36   |</span><br><span class="hljs-comment">    |________|_________|_________|_________|_________|_________|_________|_________|_________________|</span><br><span class="hljs-comment">    |        |         |         |         |         |         |         |         |        |        |</span><br><span class="hljs-comment">    |pll_ns  |   144   |   126   |   108   |   96    |   90    |   72    |   108   |   72   |   72   |</span><br><span class="hljs-comment">    |        |         |         |         |         |         |         |         |        |        |</span><br><span class="hljs-comment">    |pll_ms  |   1     |   1     |   1     |   1     |   1     |   1     |   1     |   1    |   1    |</span><br><span class="hljs-comment">    |        |         |         |         |         |         |         |         |        |        |</span><br><span class="hljs-comment">    |pll_fr  |   FR_4  |   FR_4  |   FR_4  |   FR_4  |   FR_4  |   FR_4  |   FR_8  |   FR_8 |   FR_16|</span><br><span class="hljs-comment">    |________|_________|_________|_________|_________|_________|_________|_________|________|________|</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    if pll clock source selects hext with other frequency values, or configure pll to other</span><br><span class="hljs-comment">    frequency values, please use the at32 new clock  configuration tool for configuration.  */</span><br>    crm_pll_config(CRM_PLL_SOURCE_HEXT, <span class="hljs-number">144</span>, <span class="hljs-number">1</span>, CRM_PLL_FR_4);<br><br>    <span class="hljs-comment">/* enable pll */</span><br>    crm_clock_source_enable(CRM_CLOCK_SOURCE_PLL, TRUE);<br><br>    <span class="hljs-comment">/* wait till pll is ready */</span><br>    <span class="hljs-keyword">while</span>(crm_flag_get(CRM_PLL_STABLE_FLAG) != SET)<br>    &#123;<br>    &#125;<br><br>    <span class="hljs-comment">/* config ahbclk */</span><br>    crm_ahb_div_set(CRM_AHB_DIV_1);<br><br>    <span class="hljs-comment">/* config apb2clk, the maximum frequency of APB1/APB2 clock is 144 MHz  */</span><br>    crm_apb2_div_set(CRM_APB2_DIV_2);<br><br>    <span class="hljs-comment">/* config apb1clk, the maximum frequency of APB1/APB2 clock is 144 MHz  */</span><br>    crm_apb1_div_set(CRM_APB1_DIV_2);<br><br>    <span class="hljs-comment">/* enable auto step mode */</span><br>    crm_auto_step_mode_enable(TRUE);<br><br>    <span class="hljs-comment">/* select pll as system clock source */</span><br>    crm_sysclk_switch(CRM_SCLK_PLL);<br><br>    <span class="hljs-comment">/* wait till pll is used as system clock source */</span><br>    <span class="hljs-keyword">while</span>(crm_sysclk_switch_status_get() != CRM_SCLK_PLL)<br>    &#123;<br>    &#125;<br><br>    <span class="hljs-comment">/* disable auto step mode */</span><br>    crm_auto_step_mode_enable(FALSE);<br><br>    <span class="hljs-comment">/* update system_core_clock global variable */</span><br>    system_core_clock_update();<br>    gpio_init_type gpio_init_struct;<br><br>    <span class="hljs-comment">/* enable the usart2 and gpio clock */</span><br>    crm_periph_clock_enable(CRM_USART2_PERIPH_CLOCK, TRUE);<br>    crm_periph_clock_enable(CRM_GPIOA_PERIPH_CLOCK, TRUE);<br><br>    <span class="hljs-comment">/* enable the usart3 and gpio clock */</span><br>    crm_periph_clock_enable(CRM_USART3_PERIPH_CLOCK, TRUE);<br>    crm_periph_clock_enable(CRM_GPIOB_PERIPH_CLOCK, TRUE);<br><br>    gpio_default_para_init(&amp;gpio_init_struct);<br><br>    <span class="hljs-comment">/* configure the usart2 tx, rx pin */</span><br>    gpio_init_struct.gpio_drive_strength = GPIO_DRIVE_STRENGTH_STRONGER;<br>    gpio_init_struct.gpio_out_type  = GPIO_OUTPUT_PUSH_PULL;<br>    gpio_init_struct.gpio_mode = GPIO_MODE_MUX;<br>    gpio_init_struct.gpio_pins = GPIO_PINS_2 | GPIO_PINS_3;<br>    gpio_init_struct.gpio_pull = GPIO_PULL_NONE;<br>    gpio_init(GPIOA, &amp;gpio_init_struct);<br>    gpio_pin_mux_config(GPIOA, GPIO_PINS_SOURCE2, GPIO_MUX_7);<br>    gpio_pin_mux_config(GPIOA, GPIO_PINS_SOURCE3, GPIO_MUX_7);<br><br>    <span class="hljs-comment">/* configure the usart3 tx, rx pin */</span><br>    gpio_init_struct.gpio_pins = GPIO_PINS_10 | GPIO_PINS_11;<br>    gpio_init(GPIOB, &amp;gpio_init_struct);<br>    gpio_pin_mux_config(GPIOB, GPIO_PINS_SOURCE10, GPIO_MUX_7);<br>    gpio_pin_mux_config(GPIOB, GPIO_PINS_SOURCE11, GPIO_MUX_7);<br><br>    <span class="hljs-comment">/* configure usart2 param */</span><br>    usart_init(USART2, <span class="hljs-number">115200</span>, USART_DATA_8BITS, USART_STOP_1_BIT);<br>    usart_transmitter_enable(USART2, TRUE);<br>    usart_receiver_enable(USART2, TRUE);<br>    usart_transmit_receive_pin_swap(USART2, TRUE);<br>    usart_enable(USART2, TRUE);<br><br>    <span class="hljs-comment">/* configure usart3 param */</span><br>    usart_init(USART3, <span class="hljs-number">115200</span>, USART_DATA_8BITS, USART_STOP_1_BIT);<br>    usart_transmitter_enable(USART3, TRUE);<br>    usart_receiver_enable(USART3, TRUE);<br>    usart_enable(USART3, TRUE);<br>&#125;<br></code></pre></td></tr></table></figure>在上面的串口初始配置函数中，首先对系统的时钟进行了配置，然后在对串口使用到的IO功能进行了配置，再对串口进行了配置。在一个确定的函数内部实现了三部分业务。按照下面修改后符合单一职责原则<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  config clock</span><br><span class="hljs-comment">  * @param  none</span><br><span class="hljs-comment">  * @retval none</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sysclock_configuration</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* enable pwc periph clock */</span><br>    crm_periph_clock_enable(CRM_PWC_PERIPH_CLOCK, TRUE);<br><br>    <span class="hljs-comment">/* config ldo voltage */</span><br>    pwc_ldo_output_voltage_set(PWC_LDO_OUTPUT_1V3);<br><br>    <span class="hljs-comment">/* set the flash clock divider */</span><br>    flash_clock_divider_set(FLASH_CLOCK_DIV_3);<br><br>    <span class="hljs-comment">/* reset crm */</span><br>    crm_reset();<br><br>    crm_clock_source_enable(CRM_CLOCK_SOURCE_HEXT, TRUE);<br><br>    <span class="hljs-comment">/* wait till hext is ready */</span><br>    <span class="hljs-keyword">while</span>(crm_hext_stable_wait() == ERROR)<br>    &#123;<br>    &#125;<br><br>    <span class="hljs-comment">/* config pll clock resource</span><br><span class="hljs-comment">    common frequency config list: pll source selected  hick or hext(8mhz)</span><br><span class="hljs-comment">    _________________________________________________________________________________________________</span><br><span class="hljs-comment">    |        |         |         |         |         |         |         |         |        |        |</span><br><span class="hljs-comment">    |pll(mhz)|   288   |   252   |   216   |   192   |   180   |   144   |   108   |   72   |   36   |</span><br><span class="hljs-comment">    |________|_________|_________|_________|_________|_________|_________|_________|_________________|</span><br><span class="hljs-comment">    |        |         |         |         |         |         |         |         |        |        |</span><br><span class="hljs-comment">    |pll_ns  |   144   |   126   |   108   |   96    |   90    |   72    |   108   |   72   |   72   |</span><br><span class="hljs-comment">    |        |         |         |         |         |         |         |         |        |        |</span><br><span class="hljs-comment">    |pll_ms  |   1     |   1     |   1     |   1     |   1     |   1     |   1     |   1    |   1    |</span><br><span class="hljs-comment">    |        |         |         |         |         |         |         |         |        |        |</span><br><span class="hljs-comment">    |pll_fr  |   FR_4  |   FR_4  |   FR_4  |   FR_4  |   FR_4  |   FR_4  |   FR_8  |   FR_8 |   FR_16|</span><br><span class="hljs-comment">    |________|_________|_________|_________|_________|_________|_________|_________|________|________|</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    if pll clock source selects hext with other frequency values, or configure pll to other</span><br><span class="hljs-comment">    frequency values, please use the at32 new clock  configuration tool for configuration.  */</span><br>    crm_pll_config(CRM_PLL_SOURCE_HEXT, <span class="hljs-number">144</span>, <span class="hljs-number">1</span>, CRM_PLL_FR_4);<br><br>    <span class="hljs-comment">/* enable pll */</span><br>    crm_clock_source_enable(CRM_CLOCK_SOURCE_PLL, TRUE);<br><br>    <span class="hljs-comment">/* wait till pll is ready */</span><br>    <span class="hljs-keyword">while</span>(crm_flag_get(CRM_PLL_STABLE_FLAG) != SET)<br>    &#123;<br>    &#125;<br><br>    <span class="hljs-comment">/* config ahbclk */</span><br>    crm_ahb_div_set(CRM_AHB_DIV_1);<br><br>    <span class="hljs-comment">/* config apb2clk, the maximum frequency of APB1/APB2 clock is 144 MHz  */</span><br>    crm_apb2_div_set(CRM_APB2_DIV_2);<br><br>    <span class="hljs-comment">/* config apb1clk, the maximum frequency of APB1/APB2 clock is 144 MHz  */</span><br>    crm_apb1_div_set(CRM_APB1_DIV_2);<br><br>    <span class="hljs-comment">/* enable auto step mode */</span><br>    crm_auto_step_mode_enable(TRUE);<br><br>    <span class="hljs-comment">/* select pll as system clock source */</span><br>    crm_sysclk_switch(CRM_SCLK_PLL);<br><br>    <span class="hljs-comment">/* wait till pll is used as system clock source */</span><br>    <span class="hljs-keyword">while</span>(crm_sysclk_switch_status_get() != CRM_SCLK_PLL)<br>    &#123;<br>    &#125;<br><br>    <span class="hljs-comment">/* disable auto step mode */</span><br>    crm_auto_step_mode_enable(FALSE);<br><br>    <span class="hljs-comment">/* update system_core_clock global variable */</span><br>    system_core_clock_update();<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  config uart used gpio</span><br><span class="hljs-comment">  * @param  none</span><br><span class="hljs-comment">  * @retval none</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">usart_gpio_configuration</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    gpio_init_type gpio_init_struct;<br>    crm_periph_clock_enable(CRM_GPIOA_PERIPH_CLOCK, TRUE);<br>    crm_periph_clock_enable(CRM_GPIOB_PERIPH_CLOCK, TRUE);<br>    gpio_default_para_init(&amp;gpio_init_struct);<br>    <span class="hljs-comment">/* configure the usart2 tx, rx pin */</span><br>    gpio_init_struct.gpio_drive_strength = GPIO_DRIVE_STRENGTH_STRONGER;<br>    gpio_init_struct.gpio_out_type  = GPIO_OUTPUT_PUSH_PULL;<br>    gpio_init_struct.gpio_mode = GPIO_MODE_MUX;<br>    gpio_init_struct.gpio_pins = GPIO_PINS_2 | GPIO_PINS_3;<br>    gpio_init_struct.gpio_pull = GPIO_PULL_NONE;<br>    gpio_init(GPIOA, &amp;gpio_init_struct);<br>    gpio_pin_mux_config(GPIOA, GPIO_PINS_SOURCE2, GPIO_MUX_7);<br>    gpio_pin_mux_config(GPIOA, GPIO_PINS_SOURCE3, GPIO_MUX_7);<br><br>    <span class="hljs-comment">/* configure the usart3 tx, rx pin */</span><br>    gpio_init_struct.gpio_pins = GPIO_PINS_10 | GPIO_PINS_11;<br>    gpio_init(GPIOB, &amp;gpio_init_struct);<br>    gpio_pin_mux_config(GPIOB, GPIO_PINS_SOURCE10, GPIO_MUX_7);<br>    gpio_pin_mux_config(GPIOB, GPIO_PINS_SOURCE11, GPIO_MUX_7);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  config usart</span><br><span class="hljs-comment">  * @param  none</span><br><span class="hljs-comment">  * @retval none</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">usart_configuration</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* enable the usart2 and gpio clock */</span><br>    crm_periph_clock_enable(CRM_USART2_PERIPH_CLOCK, TRUE);<br><br>    <span class="hljs-comment">/* enable the usart3 and gpio clock */</span><br>    crm_periph_clock_enable(CRM_USART3_PERIPH_CLOCK, TRUE);<br><br>    <span class="hljs-comment">/* configure usart2 param */</span><br>    usart_init(USART2, <span class="hljs-number">115200</span>, USART_DATA_8BITS, USART_STOP_1_BIT);<br>    usart_transmitter_enable(USART2, TRUE);<br>    usart_receiver_enable(USART2, TRUE);<br>    usart_transmit_receive_pin_swap(USART2, TRUE);<br>    usart_enable(USART2, TRUE);<br><br>    <span class="hljs-comment">/* configure usart3 param */</span><br>    usart_init(USART3, <span class="hljs-number">115200</span>, USART_DATA_8BITS, USART_STOP_1_BIT);<br>    usart_transmitter_enable(USART3, TRUE);<br>    usart_receiver_enable(USART3, TRUE);<br>    usart_enable(USART3, TRUE);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h2><ul><li>原则描述</li></ul><p>里氏替换原则（Liskov Substitution Principle，LSP）是由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data Abstraction and Hierarchy）里提出来的：</p><blockquote><p>继承必须确保超类所拥有的性质在子类中仍然成立。<br>Inheritance should ensure that any property proved about supertype objects also holds for subtype objects.</p></blockquote><p>简单的来说，这个原则是说子类在继承父类时，不要改变父类原有的功能。</p><p>具体的来说，这个原则可以被总结为以下四点：</p><ol><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法；</li><li>子类中可以增加自己特有的方法；</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松；</li><li>当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的的输出&#x2F;返回值）要比父类的方法更严格或相等。</li></ol><p>如果程序违背了里氏替换原则，那么在多态环境下，代码维护者由于遇到父子类行为的不一致，很容易陷入迷惑的境地，程序运行的出错概率也就随即大幅提升。</p><ul><li>原则实现</li></ul><p>我们常常会结合日常生活中对事物的感知来进行软件架构的设计，但这有时会因为违背里氏替换原则而埋下隐患，比如我们设计一个鸟类，他包含几个属性：体重、飞行速度，并且有这两个方法对应的 get、set 方法。那么，对于任何一个鸟类的对象，我们都可以通过路程&#x2F;飞行速度计算出飞行所需的时间。</p><p>然而，对于维护者来说，此时他需要创建一个“鸡”类，由于鸡不会飞，而“鸟”类中没有是否会飞的属性，意即默认“鸟”类的实现均会飞，此时，“鸡”类就不能够作为“鸟”类的子类，否则对于 getFlySpeed() 方法来说，如果“鸡”类的实现返回为 0，那么，就会造成在计算飞行时间时出现除 0 异常。</p><h2 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h2><ul><li>原则描述</li></ul><p>接口隔离原则（Interface Segregation Principle，ISP）是 2002 年罗伯特·C.马丁提出的：</p><blockquote><p>客户端不应该被迫依赖于它不使用的方法。<br>Clients should not be forced to depend on methods they do not use.</p></blockquote><p>这是不是非常类似于奥卡姆剃刀原理：如无必要，勿增实体。</p><p>这个原则也被描述为：</p><blockquote><p>一个类对另一个类的依赖应该建立在最小的接口上。<br>The dependency of one class to another one should depend on the smallest possible interface.</p></blockquote><p>如果能够遵循这一原则，模块间的依赖粒度得以最小化，那么，如果某个模块发生变更，其他模块受到的影响就会显著变小，外来变更就不会因此扩散到过大的范围，从而让项目的可维护性提升至非常高的维度。</p><p>这个原则也很有力的保障了模块间的低耦合与模块内的高内聚。</p><ul><li>原则实现</li></ul><p>在具体的实现中，我们可以尽量遵循以下四个规则：</p><ol><li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li><li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li><li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。<br>如果系统中某个模块随着业务的发展越来越庞大，适时地拆分是扼杀危险的有效手段。对模块功能进行归类，从而拆分出几个高度内聚的模块，非常有利于系统的发展。</li></ol><h2 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h2><ul><li>原则描述</li></ul><p>依赖倒置原则（Dependence Inversion Principle，DIP）是 Object Mentor 公司总裁罗伯特·马丁（Robert C.Martin）于 1996 年在 C++ Report 上发表的文章中首次提出的：</p><blockquote><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。<br>High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions.</p></blockquote><p>简单的总结，这个原则就是：</p><blockquote><p>要面向接口编程，不要面向实现编程。</p></blockquote><p>在实际的软件设计中，实现是多变的，抽象层是稳定的，因此，让模块间都通过抽象的接口或是抽象类来描述依赖，可以很大程度上降低开发风险，提升稳定性，同时也是模块间解耦的有力方法。</p><ul><li>原则实现</li></ul><p>遵循以下四点，就能在项目中满足依赖倒置规则：</p><ol><li>每个类尽量提供接口或抽象类，或者两者都具备。</li><li>变量的声明类型尽量是接口或者是抽象类。</li><li>任何类都不应该从具体类派生。</li><li>使用继承时尽量遵循里氏替换原则。</li></ol><h2 id="迪米特法则（LOD）"><a href="#迪米特法则（LOD）" class="headerlink" title="迪米特法则（LOD）"></a>迪米特法则（LOD）</h2><ul><li>原则描述</li></ul><p>迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，产生于 1987 年美国东北大学（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩·荷兰（Ian Holland）提出，被 UML 创始者之一的布奇（Booch）普及，后来又因为在经典著作《程序员修炼之道》（The Pragmatic Programmer）提及而广为人知：</p><blockquote><p>只与你的直接朋友交谈，不跟“陌生人”说话。<br>Talk only to your immediate friends and not to strangers.</p></blockquote><p>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><ul><li>原则实现</li></ul><p>在实际的开发过程中，复杂的依赖关系网往往令人无比抓狂。迪米特法则就是为了解决这一问题而诞生的。</p><p>如果你设计每个类的每个方法时都问问自己：我引入的依赖是该依赖的对象吗？我暴露的方法是应该暴露的吗？那么，你的设计一定会有显著提升。</p><p>即便是必要依赖，也要尽量降低依赖的次数，尤其是尽量不要在模块间传递序列化后的数据，由于过度泛化造成的类型不清晰，可能会让你的系统产生难以预想的问题。</p><h2 id="合成复用原则（CRP）"><a href="#合成复用原则（CRP）" class="headerlink" title="合成复用原则（CRP）"></a>合成复用原则（CRP）</h2><ul><li>原则描述</li></ul><p>合成复用原则（Composite Reuse Principle，CRP）又叫组合&#x2F;聚合复用原则（Composition&#x2F;Aggregate Reuse Principle，CARP），它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p><p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。</p><ol><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ol><ul><li>原则实现</li></ul><p>当需要扩展一个类时，优先通过类属性来进行扩展，而不是通过派生新的子类。</p><p>考虑一个实现，假设有一个“职员”类，他有四个子类：“HR”类、“RD”类、“QA”类、“SRE”类，这时，新的需求来了，要求每个职员都要拥有性别，那么，此时你如果选择将四个子类进一步派生出“男HR”类、“女HR”类、“男RD”类、“女RD”类……，你所需要维护的类继承层次就有三层，总计九个类，而如果你仅仅在父类中增添一个 gender 属性，整个继承层次并没有发生变化，相较于增加一层类继承层次，可维护性显然要高得多。</p>]]></content>
    
    
    <categories>
      
      <category>架构设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式shell组件</title>
    <link href="/2022/10/02/%E7%BB%84%E4%BB%B6-%E4%BA%A4%E4%BA%92shell%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/10/02/%E7%BB%84%E4%BB%B6-%E4%BA%A4%E4%BA%92shell%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="嵌入式交互shell实现"><a href="#嵌入式交互shell实现" class="headerlink" title="嵌入式交互shell实现"></a>嵌入式交互shell实现</h1><h2 id="模块简介"><a href="#模块简介" class="headerlink" title="模块简介"></a>模块简介</h2><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul><li>嵌入式产品中一般都会有一个通过串口或者USB等通讯方式实现的与开发人员或者测试人员交互的模块，每个产品可能的实现的方式不一样，本模块的目标是实现一个方便移植的通用性SHELL模块。</li><li>功能性需求：<ol><li>实现可以在项目的任何地方都可以注册命令</li><li>实现用户输入命令或者带参命令可以调用相关回调函数以及对参数的解析</li><li>实现对用户输入的十进制、十六进制数字进行解析取值</li><li>实现基本鉴权功能</li></ol></li><li>非功能性需求：<ol><li>可以方便移植</li><li>无需太多学习成本即可上手使用</li><li>源代码实现简洁易读，如果不满足极端场景下使用可以交给用户选择配置</li></ol></li></ul><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><ol><li>可移植性高</li><li>可读性高</li><li>可使用性高</li></ol><h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h3><ul><li>结合需求里面的“可以在项目的任意地方注册shell命令”，命令采用双向链表实现。<blockquote><p>链表的具体实现细节参考文章<a href="https://hudaxia.top/2022/10/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"><strong>链表</strong></a></p></blockquote></li><li>单个shell节点需要做出抽象，shell需要挂在链表上则需要包含节点元素；shell需包含命令字符串和需要执行的函数指针。</li><li>命令包含参数，待传参数个数不确定的情况下，则命令执行的回调函数的形参应该是(const uint8_t argc,const char *argv[]),与main函数形参类型一致。</li><li>包含鉴权功能，进入shell之前必须先输入密钥校验正确，才能正确使用shell功能。</li><li>命令格式为 “cmd param1 param2 param3 param4 …”，cmd是命令，后面的param为参数。遍历查找字符串时只对比cmd，后面的参数在命令的事件处理内部处理。</li><li>接收到串口数据包首先要对串口数据包进行分解，分解为命令带参的格式，然后再将分出来的命令进行比对查找。</li><li>单条命令以”\r”或者”\n”结尾标识</li><li>命令解析流程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">uint8_t</span><span class="hljs-params">(*Shell_function)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> argc,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">SHELLNODE</span></span><br><span class="hljs-class">&#123;</span><br>    Node node;                 <span class="hljs-comment">//挂在链表上的节点</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;          <span class="hljs-comment">//命令字符串</span><br>    Shell_function handleFunc; <span class="hljs-comment">//命令回调函数</span><br>&#125; ShellNode;<br></code></pre></td></tr></table></figure><h2 id="落地实践"><a href="#落地实践" class="headerlink" title="落地实践"></a>落地实践</h2>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FIFO组件实现</title>
    <link href="/2022/09/06/%E7%BB%84%E4%BB%B6-FIFO%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/06/%E7%BB%84%E4%BB%B6-FIFO%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="FIFO组件实现"><a href="#FIFO组件实现" class="headerlink" title="FIFO组件实现"></a>FIFO组件实现</h1><blockquote><p>fifo是指“first in，first out”先进先出数据结构</p></blockquote><h2 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h2><h3 id="1-设计目标"><a href="#1-设计目标" class="headerlink" title="1.设计目标"></a>1.设计目标</h3><ul><li>正确性</li><li>易用性</li><li>可扩展性</li></ul><h3 id="2-设计原理"><a href="#2-设计原理" class="headerlink" title="2.设计原理"></a>2.设计原理</h3><p>fifo对外提供三个接口：fifo对象的初始化、fifo数据的读取、fifo数据的写入。应用需求比较简单，内部的数据管理采用指针的形式。</p><p>目前的实现是基于u8数据类型处理，如果需要其他类型数据的可以在fifo对象中新增一个属性为数据的类型。在读写的内部实现按照数据类型的大小进行读写操作。</p><h3 id="3-实现流程"><a href="#3-实现流程" class="headerlink" title="3.实现流程"></a>3.实现流程</h3><ul><li>PUSH流程<br><img src="/img/fifo-push.png"></li><li>PULL流程<br><img src="/img/fifo-pull.png"></li></ul><h2 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h2><p><a href="https://github.com/daxia-hu/cuteFifo">cute-fifo</a></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>低功耗蓝牙技术基础</title>
    <link href="/2022/06/12/%E8%93%9D%E7%89%99-%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/06/12/%E8%93%9D%E7%89%99-%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="低功耗蓝牙技术基础"><a href="#低功耗蓝牙技术基础" class="headerlink" title="低功耗蓝牙技术基础"></a>低功耗蓝牙技术基础</h1><blockquote><p>BLE全称bluetooth low energy一般翻译为低功耗蓝牙或者蓝牙低功耗。特点是低成本、低延时、低功耗，因为目前的智能手机基本上对BLE100%的支持率，所以BLE在消费电子、物联网市场具有非常大的应用市场。</p></blockquote><blockquote><p>蓝牙的协议规范都由sig制定，sig是蓝牙技术联盟协会，由一众行业技术领先的厂商组成，官方网站<a href="https://www.bluetooth.com/">link</a>, 网站的specifications专栏中包含蓝牙技术的所有profile，这也是蓝牙开发人员务必要阅读了解的。</p></blockquote><blockquote><p>本文只是针对BLE的常用应用配置进行简述说明。<br>BLE协议栈的架构分层如下：<br><img src="/img/BLE%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82.png" alt="BLE架构分层"></p></blockquote><h2 id="一、角色配置"><a href="#一、角色配置" class="headerlink" title="一、角色配置"></a>一、角色配置</h2><p>蓝牙具有主机&#x2F;从机，客户端&#x2F;服务端，观察者&#x2F;广播者的角色概念。</p><ol><li>主机&#x2F;从机是根据连接时的行为进行区分的角色。</li><li>客户端&#x2F;服务端与主机&#x2F;从机是两个独立的概念，客户端和服务端是根据att服务访问时的数据提供和数据访问区分的角色。</li><li>观察者&#x2F;广播者是根据非连接场景下数据通信双方的行为区分的概念。<ul><li>主机：在连接这个行为中负责发现从机和发起连接从机的业务。</li><li>从机：在连接行为中负责广播自己被主机发现和被主机连接的业务。</li><li>客户端：对服务端的服务进行访问，可以对服务端进行读写行为。</li><li>服务端：给客户端提供服务，对客户端进行指示&#x2F;通知行为。</li><li>观察者：扫描广播者的广播信息。</li><li>广播者：将带有设备标识的特定信息通过广播包的信息广播出去。</li></ul></li></ol><h2 id="二、广播"><a href="#二、广播" class="headerlink" title="二、广播"></a>二、广播</h2><p>蓝牙的频率范围是2.400-2.4835 GHz，按照每个信道2MHz可以分为40个射频信道。信号频率分布如下：<br><img src="/img/%E8%93%9D%E7%89%99%E4%BF%A1%E9%81%93.png" alt="蓝牙信道"><br>设备在广播时会在3个广播信道发送相同的报文。广播需要配置广播包的内容和广播包的广播间隔。</p><h3 id="2-1-广播包"><a href="#2-1-广播包" class="headerlink" title="2.1 广播包"></a>2.1 广播包</h3><ul><li><p>广播包由包头和内容组成，包头的格式固定由以下内容组成：</p><ul><li>PDU Type：标识广播包类型<ol><li>可连接的非定向广播（Connectable Undirected Event Type）:是一种非常常用的广播类型，标识当前广播设备可以接受任何设备的扫描连接请求</li><li>可连接的定向广播（Connectable Directed Event Type）：一种为了尽快建立连接的广播方式，广播包的内容包含广播者的地址和发起者的地址，当发起者收到发给自己的广播包时，应该立即发送连接请求作为广播的回应。</li><li>不可连接的非定向广播（Non-connectable Undirected Event Type）：广播者仅仅是为了广播自己的数据，不响应扫描请求和连接请求。</li><li>可扫描的非定向广播（Scannable Undirected Event Type）：不能用于发起连接，但是允许其他设备扫描广播设备并且做出扫描响应，适用于广播者对数据的发送，但是广播者不响应连接请求。<br><img src="/img/BLE%E5%B9%BF%E6%92%AD%E7%B1%BB%E5%9E%8B.png" alt="广播类型"><br><img src="/img/%E5%B9%BF%E6%92%AD%E7%B1%BB%E5%9E%8B%E7%89%B9%E6%80%A7.png" alt="广播类型特性"></li></ol></li><li>RFU：预留</li><li>ChSel：如果本机支持跳频（Hopping）算法 #2，这设置为 1</li><li>TxAdd：代表设备的地址是随机地址还是公有地址（需要找IEEE购买），随机地址包含：<ul><li>静态地址：随机部分至少包含一个bit，上电后生成不可以修改</li><li>私有地址：<ul><li>不可以解析的私有地址：随机部分比较长，不可以被解析</li><li>可以解析的私有地址：动态修改，建议15min变化一次</li></ul></li></ul></li><li>RxAdd：代表期望对端的地址是随机地址还是公有地址</li><li>Length：代表了后面的 Payload 的长度，最大支持31个字节</li></ul></li><li><p>广播包中的数据包采用ltv格式：length、type、value的形式。type是广播的数据类型:规范文档 <a href="https://btprodspecificationrefs.blob.core.windows.net/assigned-numbers/Assigned%20Number%20Types/Assigned%20Numbers.pdf">Assigned Numbers Document</a>，包含：<br><img src="/img/BLE%E5%B9%BF%E6%92%AD%E5%8C%85%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="BLE广播包数据类型"></p></li><li><p>蓝牙core5.0新增新特性：</p><ul><li>扩展广播（LE Advertising Extensions）：原来的37、38、39为主广播信道，剩余的0-36信道为第二广播信道，当扫描设备在主广播信道接收到ADV_EXT_IND指令时，可以在指定的第二广播信道监听辅助广播数据，数据长度最大可达255字节，如果数据想要更长可以根据主广播包中的AuxPtr指向新的辅助包，通过这种方式理论上可以不断扩展长度。<br><img src="/img/5.0adv1.png" alt="5.0广播类型1"><br><img src="/img/5.0adv2.png" alt="5.0广播类型2"></li><li>long range：提高发射功率、提升接收灵敏度、 新增前向纠错编码，实际通信距离可达500-1000m</li><li>使用新的调频算法：新的跳频同时支持广播和数据通信调频，相比之前的提升性能、更加安全。</li><li>更高频率的广播：5.0以前最小支持的interval为100ms，最高速率为2.48kbps。5.0将最小值限制为20ms，提升速度为原来的5倍12.4kbps。</li></ul></li></ul><h3 id="2-2-广播配置"><a href="#2-2-广播配置" class="headerlink" title="2.2 广播配置"></a>2.2 广播配置</h3><p>蓝牙广播时会在37、38、39三个信道进行广播，在同一个环境中如果有多个设备一起广播可能会出现周期性的同时广播而互相干扰，所以蓝牙除了定向广播之外的其他广播类型广播的发送时间均会实现动态调整，实现该动态调整的方式是在每次广播事件后随机加入0-10ms的随机延时。这样当出现两个设备单词广播时间相同，那它们在下一次广播的时间大概率不会相同而互相影响。两个相邻广播事件之间的时间间隔为 advInterval + advDelay ，advInterval必须是0.625ms的整数倍，范围是20ms-10.24s。advDelay是一个链路层分配的一个伪随机数。范围是0-10ms。</p><p>一般广播的间隔配置都是设置最小广播间隔和最大广播间隔，如果需要固定广播间隔只需要将两个值设置为一个值即可。<br><img src="/img/%E5%B9%BF%E6%92%AD%E4%BA%8B%E4%BB%B6%E6%97%B6%E5%BA%8F.png" alt="广播事件时序图"></p><h2 id="三、扫描"><a href="#三、扫描" class="headerlink" title="三、扫描"></a>三、扫描</h2><p>蓝牙的扫描是指蓝牙设备的扫描者角色通过扫描环境中广播者的广播数据进行发现、广播数据传递、为连接做准备。需要注意的是扫描状态无法直接进入连接状态，只能在扫描停止后通过就绪状态进入连接状态。<br><img src="/img/ble%E6%89%AB%E6%8F%8F%E7%8A%B6%E6%80%81%E6%9C%BA.jpg" alt="ble扫描状态机"></p><h3 id="3-1-扫描类型：BLE的扫描方式分为两种主动扫描和被动扫描"><a href="#3-1-扫描类型：BLE的扫描方式分为两种主动扫描和被动扫描" class="headerlink" title="3.1 扫描类型：BLE的扫描方式分为两种主动扫描和被动扫描"></a>3.1 扫描类型：BLE的扫描方式分为两种主动扫描和被动扫描</h3><ol><li>主动扫描（active scanning）：扫描者在发现广播包后主动发起扫描请求，通过广播者的扫描响应作为一次连接前准备的交互。</li></ol><p><img src="/img/%E4%B8%BB%E5%8A%A8%E6%89%AB%E6%8F%8F%E6%97%B6%E5%BA%8F.png" alt="主动扫描时序"><br>2. 被动扫描（passive scanning）：扫描者只是发现广播者设备，但是不会发起扫描请求。</p><p><img src="/img/%E8%A2%AB%E5%8A%A8%E6%89%AB%E6%8F%8F%E6%97%B6%E5%BA%8F.png" alt="被动扫描时序"></p><p>两种扫描方式对比，主动扫描的方式会让广播者发现扫描者来暴露扫描者的信息（addr），但是被动扫描不会被扫描者发现具有一定的隐蔽性。</p><h3 id="3-2-扫描参数配置"><a href="#3-2-扫描参数配置" class="headerlink" title="3.2 扫描参数配置"></a>3.2 扫描参数配置</h3><ul><li>扫描类型：上面的两种扫描类型被动扫描（0）、主动扫描（1）</li><li>扫描窗口（windows）：一次扫描进行的时间宽度</li><li>扫描间隔（interval）：两个连续的扫描窗口之间的时间差，包括扫描休息的时间和扫描窗口的时间<br><img src="/img/BLE%E6%89%AB%E6%8F%8F%E5%8F%82%E6%95%B0.png" alt="BLE扫描参数"><ul><li>窗口和间隔可设置的时间范围是2.5ms-10.24s</li><li>扫描窗口的时间不能大于扫描间隔的时间</li><li>如果扫描窗口时间和扫描间隔时间相等，则扫描设备一直扫描，没有休息时间，带来的功耗会比较高</li></ul></li><li>扫描请求中的地址类型：包含随机地址和公有地址（设备mac地址），随机地址不会暴露自己的地址信息，相对来说更加安全。</li><li>扫描的过滤策略<ol><li>除了定向广播中包含不指向当前扫描设备的广播包，其他一律扫描</li><li>广播包地址在扫描设备白名单中或者发给扫描设备的定向广播包</li><li>所有的非定向广播包或者指向扫描设备的定向广播包或者广播地址为可解析私有地址的定向广播包</li><li>广播地址在扫描白名单或者广播地址为可解析私有地址的定向广播包或者指向扫描者地址的定向广播包</li></ol></li></ul><h3 id="3-3-扫描者设备HOST收到的扫描事件内容："><a href="#3-3-扫描者设备HOST收到的扫描事件内容：" class="headerlink" title="3.3 扫描者设备HOST收到的扫描事件内容："></a>3.3 扫描者设备HOST收到的扫描事件内容：</h3><ul><li>扫描设备数量</li><li>事件类型</li><li>广播设备地址类型</li><li>广播者地址值</li><li>广播数据长度</li><li>广播数据内容</li><li>广播者信号强度（扫描设备计算扫描到的RSSI，不能单纯的反映广播者的广播功率）</li></ul><h2 id="四、连接"><a href="#四、连接" class="headerlink" title="四、连接"></a>四、连接</h2><h2 id="五、GAP、ATT和GATT"><a href="#五、GAP、ATT和GATT" class="headerlink" title="五、GAP、ATT和GATT"></a>五、GAP、ATT和GATT</h2><h2 id="六、数据传输"><a href="#六、数据传输" class="headerlink" title="六、数据传输"></a>六、数据传输</h2><p>蓝牙在数据传输的过程中使用快速跳频算法选择需要使用到的信道。</p>]]></content>
    
    
    <categories>
      
      <category>蓝牙</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BLE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>尼尔森十大可用性原则</title>
    <link href="/2022/05/15/%E5%B0%BC%E5%B0%94%E6%A3%AE%E5%8D%81%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <url>/2022/05/15/%E5%B0%BC%E5%B0%94%E6%A3%AE%E5%8D%81%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="尼尔森十大可用性原则"><a href="#尼尔森十大可用性原则" class="headerlink" title="尼尔森十大可用性原则"></a>尼尔森十大可用性原则</h2><blockquote><p>尼尔森（Jakob Nielsen）是一位人机交互学博士，于1995年1月1日发表了「十大可用性原则」。1995年以来，他通过自己的Alertbox邮件列表以及<a href="http://useit.com/">网站</a>，向成千上万的Web设计师传授Web易用性方面的知识。<br>尼尔森的十大可用性原则是尼尔森博士分析了两百多个可用性问题而提炼出的十项通用型原则。它是产品设计与用户体验设计的重要参考标准，值得深入研究与运用。<br>这十大可用性设计原则分别是：</p><ul><li>状态可用性原则；</li><li>环境贴切原则；</li><li>撤消重做原则；</li><li>一致性原则；</li><li>防错原则；</li><li>易取原则；</li><li>灵活高效原则；</li><li>易扫原则；</li><li>容错原则；</li><li>人性化帮助原则。</li></ul></blockquote><h3 id="一、状态可见性原则（Visibility-of-system-status）"><a href="#一、状态可见性原则（Visibility-of-system-status）" class="headerlink" title="一、状态可见性原则（Visibility of system status）"></a>一、状态可见性原则（Visibility of system status）</h3><blockquote><p>系统应该让用户知道发生了什么，在适当的时间内做出适当的反馈。亦即，用户在系统上的任何操作，不论是单击、滚动还是按下键盘，页面应即时给出反馈。“即时”是指，页面响应时间小于用户能忍受的等待时间。</p></blockquote><h3 id="二、环境贴切原则（Match-between-system-and-the-real-world）"><a href="#二、环境贴切原则（Match-between-system-and-the-real-world）" class="headerlink" title="二、环境贴切原则（Match between system and the real world）"></a>二、环境贴切原则（Match between system and the real world）</h3><blockquote><p>系统应该用用户的语言，用词，短语和用户熟悉的概念，而不是系统术语。遵循现实世界的惯例，让信息符合自然思考逻辑。亦即，系统的一切表现和表述应尽可能贴近用户熟悉的环境。《IPhone人机交互指南》里提到的隐喻与拟物化是很好的实践。此外，还应尊重现实世界的惯例和约定俗成的表达。</p></blockquote><h3 id="三、撤消重做原则（User-control-and-freedom）"><a href="#三、撤消重做原则（User-control-and-freedom）" class="headerlink" title="三、撤消重做原则（User control and freedom）"></a>三、撤消重做原则（User control and freedom）</h3><blockquote><p>为了避免用户的误用和误击，系统应提供撤销和重做功能。</p></blockquote><h3 id="四、一致性原则（Consistency-and-standards）"><a href="#四、一致性原则（Consistency-and-standards）" class="headerlink" title="四、一致性原则（Consistency and standards）"></a>四、一致性原则（Consistency and standards）</h3><blockquote><p>同一用语、功能、操作保持一致。</p></blockquote><h3 id="五、防错原则（Error-prevention）"><a href="#五、防错原则（Error-prevention）" class="headerlink" title="五、防错原则（Error prevention）"></a>五、防错原则（Error prevention）</h3><blockquote><p>比出现错误信息提示更好的是更用心的设计防止这类问题发生。在用户选择动作发生之前，就要防止用户容易混淆或者错误的选择。通过系统的设计、重组或特别安排，防止用户出错。</p></blockquote><h3 id="六、易取原则：识别比记忆好（Recognition-rather-than-recall）"><a href="#六、易取原则：识别比记忆好（Recognition-rather-than-recall）" class="headerlink" title="六、易取原则：识别比记忆好（Recognition rather than recall）"></a>六、易取原则：识别比记忆好（Recognition rather than recall）</h3><blockquote><p>尽量减少用户对操作目标的记忆负荷，动作和选项应该是可见的。用户不必记忆一个页面到另一个页面的信息。系统的使用说明应该是可见或容易获取的。这也说了交互的一部分，比如填完表单，下一步应该生成表单而不是完成。这样做尽可能减少用户对操作的记忆负担，保持功能选项可见，使用说明可预见。</p></blockquote><h3 id="七、灵活高效原则（Flexibility-and-efficiency-of-use）"><a href="#七、灵活高效原则（Flexibility-and-efficiency-of-use）" class="headerlink" title="七、灵活高效原则（Flexibility and efficiency of use）"></a>七、灵活高效原则（Flexibility and efficiency of use）</h3><blockquote><p>中级用户的数量远高于初级和高级用户数。为大多数用户设计，不要低估，也不要轻视，保持灵活高效。</p></blockquote><h3 id="八、易扫原则：审美和简约的设计（Aesthetic-and-minimalist-design）"><a href="#八、易扫原则：审美和简约的设计（Aesthetic-and-minimalist-design）" class="headerlink" title="八、易扫原则：审美和简约的设计（Aesthetic and minimalist design）"></a>八、易扫原则：审美和简约的设计（Aesthetic and minimalist design）</h3><blockquote><p>用户的浏览动作不是读，不是看，而是扫。易扫，意味着突出重点，弱化和剔除无关信息。对话中不应该包含无关紧要的信息。在段落中每增加一个单位的重要信息，就意味着要减少相应的弱化一些其他信息。</p></blockquote><h3 id="九、容错原则：帮助用户识别，诊断，并从错误中恢复（Help-users-recognize-diagnose-and-recover-from-errors）"><a href="#九、容错原则：帮助用户识别，诊断，并从错误中恢复（Help-users-recognize-diagnose-and-recover-from-errors）" class="headerlink" title="九、容错原则：帮助用户识别，诊断，并从错误中恢复（Help users recognize, diagnose, and recover from errors）"></a>九、容错原则：帮助用户识别，诊断，并从错误中恢复（Help users recognize, diagnose, and recover from errors）</h3><blockquote><p>错误信息应该用语言表达（不要用代码），较准确地反应问题所在，并且提出一个建设性的解决方案。帮助用户从错误中恢复，将损失降到最低。如果无法自动挽回，则提供详尽的说明文字和指导方向，而非代码，比如404。</p></blockquote><h3 id="十、人性化帮助原则（Help-and-documentation）"><a href="#十、人性化帮助原则（Help-and-documentation）" class="headerlink" title="十、人性化帮助原则（Help and documentation）"></a>十、人性化帮助原则（Help and documentation）</h3><blockquote><p>如果系统不使用帮助文档是最好的，但是有必要提供帮助和文档。任何信息应容易去搜索，专注于用户的任务，列出具体的步骤来进行。帮助性提示最好的方式是：１.无需提示；２.一次性提示；３.常驻提示；４.帮助文档。</p></blockquote><h2 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源:"></a>资料来源:</h2><p>《尼尔森十大可用性设计原则》<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://zhuanlan.zhihu.com/p/143146361">[1]</span></a></sup></p><p>《Nielsen Norman Group logoNielsen Norman Group》<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.nngroup.com/">[2]</span></a></sup></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/143146361">https://zhuanlan.zhihu.com/p/143146361</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.nngroup.com/">https://www.nngroup.com/</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>产品需求</category>
      
    </categories>
    
    
    <tags>
      
      <tag>需求分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序员技能点</title>
    <link href="/2022/01/12/%E7%A8%8B%E5%BA%8F%E5%91%98-%E6%8A%80%E8%83%BD%E6%A0%91/"/>
    <url>/2022/01/12/%E7%A8%8B%E5%BA%8F%E5%91%98-%E6%8A%80%E8%83%BD%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="程序员技能点"><a href="#程序员技能点" class="headerlink" title="程序员技能点"></a>程序员技能点</h1><p><img src="/img/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8A%80%E8%83%BD%E6%A0%91.png" alt="程序员技能点"></p><h2 id="软件设计能力"><a href="#软件设计能力" class="headerlink" title="软件设计能力"></a>软件设计能力</h2><ul><li>需求分析</li></ul><p>在软件设计的前期阶段能够对针对产品定义对产品的需求进行分析，分析梳理出产品的功能、模式、交互等关键信息。</p><ul><li>架构设计</li></ul><p>在需求分析完成的情况下，针对产品功能的特点、开发团队的特点、及产品的其他特点对产品的软件进行整体分析，做出软件的整体架构设计。</p><ul><li>模块设计</li></ul><p>通过模块的功能和整体架构设计，结合长期的开发经验和对优秀代码的阅读对软件的单个模块进行软件设计，设计模块的结构分层、状态管理、关键业务实现流程等。</p><h2 id="编码能力"><a href="#编码能力" class="headerlink" title="编码能力"></a>编码能力</h2><ul><li>功能实现</li></ul><p>编码实现软件预期实现的功能，保证功能实现的正确性和完整性。</p><ul><li>编码规范</li></ul><p>编码规范包含编码风格习惯、软件的执行效率（代码复杂度）等。</p><h2 id="学习能力"><a href="#学习能力" class="headerlink" title="学习能力"></a>学习能力</h2><ul><li>学习方法</li></ul><p>针对新知识点的高效率学习方法。<br>    - 学习阶段要注重学习内功，由内而外的学习。假设学习计算机语言中的“循环”结构，应该先基于循环的应用场景、循环的实现原理去思考，再去看for、while等语法的实现。而不是先熟练背诵for、while语法再去思考循环。</p><ul><li>学习兴趣</li></ul><p>有对工作中新知识学习的好奇心。</p><h2 id="问题分析解决能力"><a href="#问题分析解决能力" class="headerlink" title="问题分析解决能力"></a>问题分析解决能力</h2><ul><li>问题分析</li></ul><p>具有基本常见问题的分析方法，针对特殊问题具有清晰的分析思路，排查过程中逐步减小范围一直找到问题的根本原因。</p><ul><li>问题解决</li></ul><p>在问题定位清楚的情况下具有正确解决问题的能力，妥善的解决问题既要解决现有问题又不能引入新的问题，针对常见问题建立个人或者公司项目的问题库，持续维护。</p><h2 id="文档编写能力"><a href="#文档编写能力" class="headerlink" title="文档编写能力"></a>文档编写能力</h2><ul><li>文档格式</li></ul><p>清晰明确的文档层次格式、字体格式等，可以让输出的文档具有高可读性。</p><ul><li>文档内容</li></ul><p>表达观点的论文具有明确坚定的文档观点，记录文档有清晰的文档内容，适当的图形表示可以让文档的表达更加直观明白。</p><h2 id="表达能力"><a href="#表达能力" class="headerlink" title="表达能力"></a>表达能力</h2><ul><li>演讲能力</li></ul><p>在对多人演讲过程中能提起观众的兴趣、通过准确的语句对演讲内容进行表达。</p><ul><li>沟通能力</li></ul><p>在与人沟通过程中做到明确自己的表达观点、仔细倾听别人的观点内容。</p>]]></content>
    
    
    <categories>
      
      <category>程序员</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序员</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>读书</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h2 id="图书资源"><a href="#图书资源" class="headerlink" title="图书资源"></a>图书资源</h2><h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><ul><li><a href="https://pan.baidu.com/s/1DdZJm8mRc7304AEbkQ3Fbg">C.Primer.Plus第五版中文版+源码</a> 提取码：nd2z </li><li><a href="https://pan.baidu.com/s/1drKfiFbjtBZSINowmJytng">C标准库</a> 提取码：wctp </li><li><a href="https://pan.baidu.com/s/1JtGnqNATv1TmWa-EU7etGQ">C专家编程</a> 提取码：zxmy</li><li><a href="https://pan.baidu.com/s/15EXOgnGtbfpsYvLq_ta4yQ">C和指针</a> 提取码：d67j</li><li><a href="https://pan.baidu.com/s/1t2HF3uPIX3JcS0_S0GYcCg">CPrimerPlus(6thEdition)</a> 提取码：wzgy</li><li><a href="https://pan.baidu.com/s/1lxAu5nGvekkXaT2Ob9-Big">C陷阱和缺陷</a> 提取码：tnga</li></ul><h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><ul><li><a href="https://pan.baidu.com/s/1DDAsBfJZMKMODrQ6xTjxEQ">C++沉思录(Ruminations on C++)中文第2版</a> 提取码：g9os</li></ul><h4 id="QT"><a href="#QT" class="headerlink" title="QT"></a>QT</h4><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><ul><li><a href="https://pan.baidu.com/s/163SMtuJQGZIsMP2DxxuqWA">Java核心技术卷1基础知识原书第10版</a> 提取码：3iph</li><li><a href="https://pan.baidu.com/s/17yQ3vCrYTksZ9TU9zXmB9w">java开发手册2020</a> 提取码：fv7u</li></ul><h4 id="PYTHON"><a href="#PYTHON" class="headerlink" title="PYTHON"></a>PYTHON</h4><h4 id="善用工具"><a href="#善用工具" class="headerlink" title="善用工具"></a>善用工具</h4><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><ul><li><a href="%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://pan.baidu.com/s/1wJMJaRWZgSCcYKtmW5ttiA">代码整洁之道 中文版</a> 提取码：8uad </li><li><a href="https://pan.baidu.com/s/1GvKdxPd1Z-yx26moVvRE4g">重构_改善既有代码的设计-高清版</a> 提取码：muc1</li><li><a href="https://pan.baidu.com/s/1hWA_N2bZFIFX0kbhTMzoCg">设计模式_可复用面向对象软件的基础</a> 提取码：lqb2</li><li><a href="https://pan.baidu.com/s/1mjA6sm2hi_0lRZI0NPa09w">大话设计模式(带目录完整版)</a> 提取码：tckf</li><li><a href="https://pan.baidu.com/s/1GQ7UvdBT1uwoRkkqgtXJlg">Making Embedded Systems(2012)</a> 提取码：qbqz</li><li><a href="https://pan.baidu.com/s/18BcuRFXDnH7182L4XZLxCw">An Embedded Software Primer (1ed - Simon)</a> 提取码：265y</li><li><a href="https://pan.baidu.com/s/1Ib7v29HUYD4vahRArsmQYQ">Head First 设计模式(中文版)</a> 提取码：ek9c</li></ul><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><h4 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h4><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><a href="https://pan.baidu.com/s/139Ii5NnN1P0PAL2fvUBTgQ">程序员的自我修养</a> 提取码：zlqf</li><li><a href="https://pan.baidu.com/s/1omkGyEbyAUoir1ojkdyYIw">人月神话</a> 提取码：xf4c</li><li><a href="https://pan.baidu.com/s/1MulttspChabGJVzMuVqrlA">人件</a> 提取码：jg8k</li><li><a href="https://pan.baidu.com/s/1eAEFSpaYXtQIzlCF8NZ0ag">黑客与画家</a> 提取码：xp7i</li><li><a href="https://pan.baidu.com/s/1ij8FEmRG3A1DavyieSvZRg">浪潮之巅</a> 提取码：3qrg</li><li><a href="https://pan.baidu.com/s/1aaDd0JcWUWrISa58tV-lrA">代码大全（第二版)</a> 提取码：yz3v</li><li><a href="https://pan.baidu.com/s/1aaGejvCOtT43tki6UsId9A">代码大全</a> 提取码：cyea</li><li><a href="https://pan.baidu.com/s/1kK29AhRN-QfFhNqx_UoxWA">编程珠玑高清</a> 提取码：eyco</li></ul><h2 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h2><!-- - [《谁动了我的奶酪》](谁动了我的奶酪.html) --><!-- - [《在绝望中寻找希望》](在绝望中寻找希望.html) -->]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>《谁动了我的奶酪》</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h2 id="《谁动了我的奶酪》读书笔记"><a href="#《谁动了我的奶酪》读书笔记" class="headerlink" title="《谁动了我的奶酪》读书笔记"></a>《谁动了我的奶酪》读书笔记</h2><blockquote><p>《谁动了我的奶酪》是美国作家斯宾塞·约翰逊与1998年出版的一个寓言故事，其中描写了两个老鼠和两个小人在迷宫中找奶酪的故事，故事简洁寓意深刻，故事的寓意耐人寻味，在出版的20多年间影响了很多读者。</p></blockquote><blockquote><p>故事大概描述：在很久以前的一个迷宫里，住着两个老鼠和两个小人，老鼠的名字分别叫“匆匆”和“嗅嗅”，小人的名字分别叫“哼哼”和“唧唧”，他们四个每天在迷宫里面四处寻找奶酪维持生活，迷宫里面的生存环境非常不好，他们经常迷路或者在迷宫里面摔伤，但是每天早上他们都信心满满的出发重新寻找。突然有一天他们在迷宫的奶酪C区看到了非常多新鲜的奶酪，里面还有蛋糕芝士等等，他们开心极了，此后的几年时间里他们都每天准时出发到达奶酪C区。<br>两只小老鼠会把鞋子绑在一起挂在脖子上，原因是他们习惯了之前寻找奶酪的那段时间，把鞋子挂在脖子上是为了当奶酪没有时随时寻找新的奶酪，慢慢的随着时间的推移，两个小人“哼哼”和“唧唧”每天来的越来越晚，他们觉得这里就是天堂，这里的奶酪都够他们吃一辈子的了。可是他们没注意到奶酪越来越少，而且奶酪也慢慢发霉了，直到有一天两只小老鼠“匆匆”和“嗅嗅”到达C区后发现奶酪已经没有了，他们没有迟疑和以前的很多次一样穿上鞋子重新进入迷宫寻找新的奶酪，等到两个小人“哼哼”和“唧唧”到达奶酪C区后他们简直不敢相信自己的眼睛，奶酪C区竟然一点奶酪都没有了，他们以为是自己走错了地方或者产生了幻觉，因为他们觉得这里的奶酪不可能没有的。后面他们就在奶酪C区思考奶酪去了哪里，“哼哼”甚至在想这肯定是什么阴谋，不停的抱怨这不公平，此后的每一天他们每天都来到奶酪C区，幻想着这一切都没发生过，渐渐地由于他们没有奶酪吃老是会产生幻觉，他们幻想自己还和以前一样每天到这里享用美味的奶酪，“唧唧”也想过离开这里去寻找新的奶酪，就像最开始那样。但是这里待着实在太舒服了，想到以前在迷宫里面那些迷路和受伤的场景，他们又开始抱怨上天的不公平，渐渐地他们的身体越来越虚弱。突然有一天“唧唧”觉得不能再这样下去了，他叫“哼哼”和自己一起出去寻找新的奶酪，但是“哼哼”还在抱怨，抱怨慢慢的转为愤怒，他不愿意去重新进入迷宫寻找奶酪，以前在迷宫受的那些伤让他非常的恐惧。就这样“唧唧”重新出发了，刚开始“唧唧”每天都想回去奶酪C区在里面舒服的待着，迷宫里面的奶酪还是不太好找，但是当他想起奶酪C区那段充满恐惧与怨气的时间时，他又有了去寻找的动力，他甚至想到在另外一个地方和奶酪C区一样，也有很多很多新鲜的奶酪，想到这里他就浑身充满力气。直到有一天，“唧唧”来到奶酪F区，他在这里又看到了很多奶酪和他的老朋友“嗅嗅”和“匆匆”，他开心极了他把鞋子挂到了脖子上开始享用美味的奶酪。</p></blockquote><h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><h2 id="关于心态"><a href="#关于心态" class="headerlink" title="关于心态"></a>关于心态</h2><h2 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h2><p>微信读书《谁动了我的奶酪》<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://weread.qq.com/web/bookDetail/9eb32a6059b42c9ebc1da49">[1]</span></a></sup></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://weread.qq.com/web/bookDetail/9eb32a6059b42c9ebc1da49">https://weread.qq.com/web/bookDetail/9eb32a6059b42c9ebc1da49</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>《在绝望中寻找希望》</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h1 id="关于教育"><a href="#关于教育" class="headerlink" title="关于教育"></a>关于教育</h1><h1 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h1><h1 id="关于韧性"><a href="#关于韧性" class="headerlink" title="关于韧性"></a>关于韧性</h1><h1 id="关于朋友"><a href="#关于朋友" class="headerlink" title="关于朋友"></a>关于朋友</h1><h1 id="关于心态"><a href="#关于心态" class="headerlink" title="关于心态"></a>关于心态</h1>]]></content>
    
  </entry>
  
  
  
</search>
